//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 12 storyboards.
  struct storyboard {
    /// Storyboard `AddDiary`.
    static let addDiary = _R.storyboard.addDiary()
    /// Storyboard `ImageEdit`.
    static let imageEdit = _R.storyboard.imageEdit()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `OpenSourceLicense`.
    static let openSourceLicense = _R.storyboard.openSourceLicense()
    /// Storyboard `Privacy`.
    static let privacy = _R.storyboard.privacy()
    /// Storyboard `UserAlbum`.
    static let userAlbum = _R.storyboard.userAlbum()
    /// Storyboard `UserAppVersion`.
    static let userAppVersion = _R.storyboard.userAppVersion()
    /// Storyboard `UserDiary`.
    static let userDiary = _R.storyboard.userDiary()
    /// Storyboard `UserSetting`.
    static let userSetting = _R.storyboard.userSetting()
    /// Storyboard `UserTagAlbumDetail`.
    static let userTagAlbumDetail = _R.storyboard.userTagAlbumDetail()
    /// Storyboard `UserTagAlbum`.
    static let userTagAlbum = _R.storyboard.userTagAlbum()
    /// Storyboard `UserTagSelect`.
    static let userTagSelect = _R.storyboard.userTagSelect()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "AddDiary", bundle: ...)`
    static func addDiary(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.addDiary)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "ImageEdit", bundle: ...)`
    static func imageEdit(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.imageEdit)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "OpenSourceLicense", bundle: ...)`
    static func openSourceLicense(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.openSourceLicense)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Privacy", bundle: ...)`
    static func privacy(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.privacy)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserAlbum", bundle: ...)`
    static func userAlbum(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userAlbum)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserAppVersion", bundle: ...)`
    static func userAppVersion(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userAppVersion)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserDiary", bundle: ...)`
    static func userDiary(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userDiary)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserSetting", bundle: ...)`
    static func userSetting(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userSetting)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserTagAlbum", bundle: ...)`
    static func userTagAlbum(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userTagAlbum)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserTagAlbumDetail", bundle: ...)`
    static func userTagAlbumDetail(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userTagAlbumDetail)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "UserTagSelect", bundle: ...)`
    static func userTagSelect(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.userTagSelect)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 11 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `bear`.
    static let bear = Rswift.ColorResource(bundle: R.hostingBundle, name: "bear")
    /// Color `black`.
    static let black = Rswift.ColorResource(bundle: R.hostingBundle, name: "black")
    /// Color `blue`.
    static let blue = Rswift.ColorResource(bundle: R.hostingBundle, name: "blue")
    /// Color `green`.
    static let green = Rswift.ColorResource(bundle: R.hostingBundle, name: "green")
    /// Color `orange`.
    static let orange = Rswift.ColorResource(bundle: R.hostingBundle, name: "orange")
    /// Color `pink`.
    static let pink = Rswift.ColorResource(bundle: R.hostingBundle, name: "pink")
    /// Color `purple`.
    static let purple = Rswift.ColorResource(bundle: R.hostingBundle, name: "purple")
    /// Color `red`.
    static let red = Rswift.ColorResource(bundle: R.hostingBundle, name: "red")
    /// Color `white`.
    static let white = Rswift.ColorResource(bundle: R.hostingBundle, name: "white")
    /// Color `yellow`.
    static let yellow = Rswift.ColorResource(bundle: R.hostingBundle, name: "yellow")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "bear", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func bear(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.bear, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "black", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func black(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.black, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "blue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func blue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.blue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "green", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func green(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.green, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "orange", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func orange(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.orange, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "pink", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func pink(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.pink, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "purple", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func purple(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.purple, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "red", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func red(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.red, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "white", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func white(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.white, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "yellow", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func yellow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.yellow, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func accentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.accentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "bear", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func bear(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.bear.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "black", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func black(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.black.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "blue", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func blue(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.blue.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "green", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func green(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.green.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "orange", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func orange(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.orange.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "pink", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func pink(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.pink.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "purple", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func purple(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.purple.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "red", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func red(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.red.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "white", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func white(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.white.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "yellow", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func yellow(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.yellow.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 9 files.
  struct file {
    /// Resource file `DungGeunMo.otf`.
    static let dungGeunMoOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "DungGeunMo", pathExtension: "otf")
    /// Resource file `HeirofLightOTFBold.otf`.
    static let heirofLightOTFBoldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "HeirofLightOTFBold", pathExtension: "otf")
    /// Resource file `JejuMyeongjoOTF.otf`.
    static let jejuMyeongjoOTFOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "JejuMyeongjoOTF", pathExtension: "otf")
    /// Resource file `KOTRA HOPE_OTF.otf`.
    static let kotrahope_OTFOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "KOTRA HOPE_OTF", pathExtension: "otf")
    /// Resource file `KOTRA LEAP_OTF.otf`.
    static let kotraleap_OTFOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "KOTRA LEAP_OTF", pathExtension: "otf")
    /// Resource file `KOTRA_SONGEULSSI.otf`.
    static let kotra_SONGEULSSIOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "KOTRA_SONGEULSSI", pathExtension: "otf")
    /// Resource file `Kyobo Handwriting 2019.otf`.
    static let kyoboHandwriting2019Otf = Rswift.FileResource(bundle: R.hostingBundle, name: "Kyobo Handwriting 2019", pathExtension: "otf")
    /// Resource file `OpenSource.html`.
    static let openSourceHtml = Rswift.FileResource(bundle: R.hostingBundle, name: "OpenSource", pathExtension: "html")
    /// Resource file `esamanru OTF Bold.otf`.
    static let esamanruOTFBoldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "esamanru OTF Bold", pathExtension: "otf")

    /// `bundle.url(forResource: "DungGeunMo", withExtension: "otf")`
    static func dungGeunMoOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.dungGeunMoOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "HeirofLightOTFBold", withExtension: "otf")`
    static func heirofLightOTFBoldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.heirofLightOTFBoldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "JejuMyeongjoOTF", withExtension: "otf")`
    static func jejuMyeongjoOTFOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.jejuMyeongjoOTFOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "KOTRA HOPE_OTF", withExtension: "otf")`
    static func kotrahope_OTFOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.kotrahope_OTFOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "KOTRA LEAP_OTF", withExtension: "otf")`
    static func kotraleap_OTFOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.kotraleap_OTFOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "KOTRA_SONGEULSSI", withExtension: "otf")`
    static func kotra_SONGEULSSIOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.kotra_SONGEULSSIOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "Kyobo Handwriting 2019", withExtension: "otf")`
    static func kyoboHandwriting2019Otf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.kyoboHandwriting2019Otf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "OpenSource", withExtension: "html")`
    static func openSourceHtml(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.openSourceHtml
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "esamanru OTF Bold", withExtension: "otf")`
    static func esamanruOTFBoldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.esamanruOTFBoldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 8 fonts.
  struct font: Rswift.Validatable {
    /// Font `DungGeunMo`.
    static let dungGeunMo = Rswift.FontResource(fontName: "DungGeunMo")
    /// Font `HeirofLightOTFBold`.
    static let heirofLightOTFBold = Rswift.FontResource(fontName: "HeirofLightOTFBold")
    /// Font `JejuMyeongjoOTF`.
    static let jejuMyeongjoOTF = Rswift.FontResource(fontName: "JejuMyeongjoOTF")
    /// Font `KOTRAHOPE`.
    static let kotrahopE = Rswift.FontResource(fontName: "KOTRAHOPE")
    /// Font `KOTRALEAP`.
    static let kotraleaP = Rswift.FontResource(fontName: "KOTRALEAP")
    /// Font `KOTRA_SONGEULSSI-Medium`.
    static let kotra_SONGEULSSIMedium = Rswift.FontResource(fontName: "KOTRA_SONGEULSSI-Medium")
    /// Font `KyoboHandwriting2019`.
    static let kyoboHandwriting2019 = Rswift.FontResource(fontName: "KyoboHandwriting2019")
    /// Font `esamanruOTFBold`.
    static let esamanruOTFBold = Rswift.FontResource(fontName: "esamanruOTFBold")

    /// `UIFont(name: "DungGeunMo", size: ...)`
    static func dungGeunMo(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: dungGeunMo, size: size)
    }

    /// `UIFont(name: "HeirofLightOTFBold", size: ...)`
    static func heirofLightOTFBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: heirofLightOTFBold, size: size)
    }

    /// `UIFont(name: "JejuMyeongjoOTF", size: ...)`
    static func jejuMyeongjoOTF(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: jejuMyeongjoOTF, size: size)
    }

    /// `UIFont(name: "KOTRAHOPE", size: ...)`
    static func kotrahopE(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: kotrahopE, size: size)
    }

    /// `UIFont(name: "KOTRALEAP", size: ...)`
    static func kotraleaP(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: kotraleaP, size: size)
    }

    /// `UIFont(name: "KOTRA_SONGEULSSI-Medium", size: ...)`
    static func kotra_SONGEULSSIMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: kotra_SONGEULSSIMedium, size: size)
    }

    /// `UIFont(name: "KyoboHandwriting2019", size: ...)`
    static func kyoboHandwriting2019(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: kyoboHandwriting2019, size: size)
    }

    /// `UIFont(name: "esamanruOTFBold", size: ...)`
    static func esamanruOTFBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: esamanruOTFBold, size: size)
    }

    static func validate() throws {
      if R.font.dungGeunMo(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'DungGeunMo' could not be loaded, is 'DungGeunMo.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.heirofLightOTFBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'HeirofLightOTFBold' could not be loaded, is 'HeirofLightOTFBold.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.jejuMyeongjoOTF(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'JejuMyeongjoOTF' could not be loaded, is 'JejuMyeongjoOTF.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.kotrahopE(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'KOTRAHOPE' could not be loaded, is 'KOTRA HOPE_OTF.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.kotraleaP(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'KOTRALEAP' could not be loaded, is 'KOTRA LEAP_OTF.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.kotra_SONGEULSSIMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'KOTRA_SONGEULSSI-Medium' could not be loaded, is 'KOTRA_SONGEULSSI.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.kyoboHandwriting2019(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'KyoboHandwriting2019' could not be loaded, is 'Kyobo Handwriting 2019.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.esamanruOTFBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'esamanruOTFBold' could not be loaded, is 'esamanru OTF Bold.otf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 8 images.
  struct image {
    /// Image `TimeBearTitle1`.
    static let timeBearTitle1 = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBearTitle1")
    /// Image `TimeBearTitle2`.
    static let timeBearTitle2 = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBearTitle2")
    /// Image `TimeBear_Clear_100`.
    static let timeBear_Clear_100 = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBear_Clear_100")
    /// Image `TimeBear_Clear_25`.
    static let timeBear_Clear_25 = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBear_Clear_25")
    /// Image `TimeBear_Clear_500`.
    static let timeBear_Clear_500 = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBear_Clear_500")
    /// Image `TimeBear_Clear_50`.
    static let timeBear_Clear_50 = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBear_Clear_50")
    /// Image `TimeBear`.
    static let timeBear = Rswift.ImageResource(bundle: R.hostingBundle, name: "TimeBear")
    /// Image `buttonBlack`.
    static let buttonBlack = Rswift.ImageResource(bundle: R.hostingBundle, name: "buttonBlack")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBear", bundle: ..., traitCollection: ...)`
    static func timeBear(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBear, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBearTitle1", bundle: ..., traitCollection: ...)`
    static func timeBearTitle1(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBearTitle1, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBearTitle2", bundle: ..., traitCollection: ...)`
    static func timeBearTitle2(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBearTitle2, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBear_Clear_100", bundle: ..., traitCollection: ...)`
    static func timeBear_Clear_100(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBear_Clear_100, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBear_Clear_25", bundle: ..., traitCollection: ...)`
    static func timeBear_Clear_25(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBear_Clear_25, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBear_Clear_50", bundle: ..., traitCollection: ...)`
    static func timeBear_Clear_50(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBear_Clear_50, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "TimeBear_Clear_500", bundle: ..., traitCollection: ...)`
    static func timeBear_Clear_500(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.timeBear_Clear_500, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "buttonBlack", bundle: ..., traitCollection: ...)`
    static func buttonBlack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.buttonBlack, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "UserAlbum"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        struct uiWindowSceneSessionRoleExternalDisplay {
          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 17 nibs.
  struct nib {
    /// Nib `DesignCollectionViewCell`.
    static let designCollectionViewCell = _R.nib._DesignCollectionViewCell()
    /// Nib `Stamp_10`.
    static let stamp_10 = _R.nib._Stamp_10()
    /// Nib `Stamp_11`.
    static let stamp_11 = _R.nib._Stamp_11()
    /// Nib `Stamp_12`.
    static let stamp_12 = _R.nib._Stamp_12()
    /// Nib `Stamp_13`.
    static let stamp_13 = _R.nib._Stamp_13()
    /// Nib `Stamp_14`.
    static let stamp_14 = _R.nib._Stamp_14()
    /// Nib `Stamp_15`.
    static let stamp_15 = _R.nib._Stamp_15()
    /// Nib `Stamp_1`.
    static let stamp_1 = _R.nib._Stamp_1()
    /// Nib `Stamp_2`.
    static let stamp_2 = _R.nib._Stamp_2()
    /// Nib `Stamp_3`.
    static let stamp_3 = _R.nib._Stamp_3()
    /// Nib `Stamp_4`.
    static let stamp_4 = _R.nib._Stamp_4()
    /// Nib `Stamp_5`.
    static let stamp_5 = _R.nib._Stamp_5()
    /// Nib `Stamp_6`.
    static let stamp_6 = _R.nib._Stamp_6()
    /// Nib `Stamp_7`.
    static let stamp_7 = _R.nib._Stamp_7()
    /// Nib `Stamp_8`.
    static let stamp_8 = _R.nib._Stamp_8()
    /// Nib `Stamp_9`.
    static let stamp_9 = _R.nib._Stamp_9()
    /// Nib `TagAlbumCollectionViewCell`.
    static let tagAlbumCollectionViewCell = _R.nib._TagAlbumCollectionViewCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "DesignCollectionViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.designCollectionViewCell) instead")
    static func designCollectionViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.designCollectionViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_1", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_1) instead")
    static func stamp_1(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_1)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_10", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_10) instead")
    static func stamp_10(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_10)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_11", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_11) instead")
    static func stamp_11(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_11)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_12", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_12) instead")
    static func stamp_12(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_12)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_13", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_13) instead")
    static func stamp_13(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_13)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_14", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_14) instead")
    static func stamp_14(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_14)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_15", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_15) instead")
    static func stamp_15(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_15)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_2", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_2) instead")
    static func stamp_2(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_2)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_3", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_3) instead")
    static func stamp_3(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_3)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_4", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_4) instead")
    static func stamp_4(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_4)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_5", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_5) instead")
    static func stamp_5(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_5)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_6", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_6) instead")
    static func stamp_6(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_6)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_7", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_7) instead")
    static func stamp_7(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_7)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_8", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_8) instead")
    static func stamp_8(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_8)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "Stamp_9", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stamp_9) instead")
    static func stamp_9(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stamp_9)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TagAlbumCollectionViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.tagAlbumCollectionViewCell) instead")
    static func tagAlbumCollectionViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.tagAlbumCollectionViewCell)
    }
    #endif

    static func designCollectionViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> DesignCollectionViewCell? {
      return R.nib.designCollectionViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? DesignCollectionViewCell
    }

    static func stamp_1(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_1.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_10(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_10.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_11(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_11.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_12(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_12.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_13(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_13.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_14(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_14.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_15(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_15.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_2(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_2.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_3(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_3.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_4(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_4.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_5(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_5.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_6(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_6.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_7(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_7.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_8(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_8.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stamp_9(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stamp_9.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func tagAlbumCollectionViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TagAlbumCollectionViewCell? {
      return R.nib.tagAlbumCollectionViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TagAlbumCollectionViewCell
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 6 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `DesignCollectionViewCell`.
    static let designCollectionViewCell: Rswift.ReuseIdentifier<DesignCollectionViewCell> = Rswift.ReuseIdentifier(identifier: "DesignCollectionViewCell")
    /// Reuse identifier `DiaryTagTableViewCell`.
    static let diaryTagTableViewCell: Rswift.ReuseIdentifier<DiaryTagTableViewCell> = Rswift.ReuseIdentifier(identifier: "DiaryTagTableViewCell")
    /// Reuse identifier `SettingTableViewCell`.
    static let settingTableViewCell: Rswift.ReuseIdentifier<SettingTableViewCell> = Rswift.ReuseIdentifier(identifier: "SettingTableViewCell")
    /// Reuse identifier `TagAlbumCollectionViewCell`.
    static let tagAlbumCollectionViewCell: Rswift.ReuseIdentifier<TagAlbumCollectionViewCell> = Rswift.ReuseIdentifier(identifier: "TagAlbumCollectionViewCell")
    /// Reuse identifier `TimeStampDesignCell`.
    static let timeStampDesignCell: Rswift.ReuseIdentifier<TimeStampDesignCollectionViewCell> = Rswift.ReuseIdentifier(identifier: "TimeStampDesignCell")
    /// Reuse identifier `UserTagSelectTableViewCell`.
    static let userTagSelectTableViewCell: Rswift.ReuseIdentifier<UserTagSelectTableViewCell> = Rswift.ReuseIdentifier(identifier: "UserTagSelectTableViewCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 3 localization tables.
  struct string {
    /// This `R.string.infoPlist` struct is generated, and contains static references to 3 localization keys.
    struct infoPlist {
      /// en translation: TimeBear
      ///
      /// Locales: en, ko
      static let cfBundleDisplayName = Rswift.StringResource(key: "CFBundleDisplayName", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: To create a timestamp image we need user's camera access permission
      ///
      /// Locales: en, ko
      static let nsCameraUsageDescription = Rswift.StringResource(key: "NSCameraUsageDescription", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: To save the generated timestamp image in the album we need user's access permission
      ///
      /// Locales: en, ko
      static let nsPhotoLibraryAddUsageDescription = Rswift.StringResource(key: "NSPhotoLibraryAddUsageDescription", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)

      /// en translation: TimeBear
      ///
      /// Locales: en, ko
      static func cfBundleDisplayName(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("CFBundleDisplayName", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "CFBundleDisplayName"
        }

        return NSLocalizedString("CFBundleDisplayName", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      /// en translation: To create a timestamp image we need user's camera access permission
      ///
      /// Locales: en, ko
      static func nsCameraUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSCameraUsageDescription", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "NSCameraUsageDescription"
        }

        return NSLocalizedString("NSCameraUsageDescription", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      /// en translation: To save the generated timestamp image in the album we need user's access permission
      ///
      /// Locales: en, ko
      static func nsPhotoLibraryAddUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSPhotoLibraryAddUsageDescription", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "NSPhotoLibraryAddUsageDescription"
        }

        return NSLocalizedString("NSPhotoLibraryAddUsageDescription", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.launchScreen` struct is generated, and contains static references to 1 localization keys.
    struct launchScreen {
      /// ko translation: TimeDiary
      ///
      /// Locales: ko
      static let rtgPJ122Text = Rswift.StringResource(key: "Rtg-pJ-122.text", tableName: "LaunchScreen", bundle: R.hostingBundle, locales: ["ko"], comment: nil)

      /// ko translation: TimeDiary
      ///
      /// Locales: ko
      static func rtgPJ122Text(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("Rtg-pJ-122.text", tableName: "LaunchScreen", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "LaunchScreen", preferredLanguages: preferredLanguages) else {
          return "Rtg-pJ-122.text"
        }

        return NSLocalizedString("Rtg-pJ-122.text", tableName: "LaunchScreen", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.localizable` struct is generated, and contains static references to 46 localization keys.
    struct localizable {
      /// en translation: Add Folder
      ///
      /// Locales: en, ko
      static let addFolderTitle = Rswift.StringResource(key: "addFolderTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Do you really want to delete the diary?
      ///
      /// Locales: en, ko
      static let deleteDiaryMessage = Rswift.StringResource(key: "deleteDiaryMessage", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Do you really want to delete the folder? All images in the folder will be deleted.
      ///
      /// Locales: en, ko
      static let deleteFolderMessage = Rswift.StringResource(key: "deleteFolderMessage", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Folder creation has been canceled
      ///
      /// Locales: en, ko
      static let addFolderCancleToast = Rswift.StringResource(key: "addFolderCancleToast", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Folder creation has been failed
      ///
      /// Locales: en, ko
      static let addFolderFailToast = Rswift.StringResource(key: "addFolderFailToast", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: If you leave this page, the created content will not be saved. Please save the contents.
      ///
      /// Locales: en, ko
      static let needSaveMessage = Rswift.StringResource(key: "needSaveMessage", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: My Diary
      ///
      /// Locales: en, ko
      static let myDiary = Rswift.StringResource(key: "my diary", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Please enter a text that's not blank
      ///
      /// Locales: en, ko
      static let addFolderEmptyName = Rswift.StringResource(key: "addFolderEmptyName", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Please enter it in 15 letters or less
      ///
      /// Locales: en, ko
      static let addFolderLongName = Rswift.StringResource(key: "addFolderLongName", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Please enter less than 1,000 characters.
      ///
      /// Locales: en, ko
      static let longContent = Rswift.StringResource(key: "longContent", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Please enter the folder name you want to add
      ///
      /// Locales: en, ko
      static let addFolderMessage = Rswift.StringResource(key: "addFolderMessage", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Please make a timestamp image!
      ///
      /// Locales: en, ko
      static let guide = Rswift.StringResource(key: "guide", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Setting
      ///
      /// Locales: en, ko
      static let setting = Rswift.StringResource(key: "setting", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: There's no diary yet!
      ///
      /// Locales: en, ko
      static let noDiary = Rswift.StringResource(key: "noDiary", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: add
      ///
      /// Locales: en, ko
      static let add = Rswift.StringResource(key: "add", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: album
      ///
      /// Locales: en, ko
      static let album = Rswift.StringResource(key: "album", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: alert
      ///
      /// Locales: en, ko
      static let alert = Rswift.StringResource(key: "alert", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: all
      ///
      /// Locales: en, ko
      static let all = Rswift.StringResource(key: "all", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: app is not allowed to access the camera. Do you want to go to the setting screen?
      ///
      /// Locales: en, ko
      static let accessSetting = Rswift.StringResource(key: "accessSetting", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: app version
      ///
      /// Locales: en, ko
      static let appVersion = Rswift.StringResource(key: "appVersion", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: attention
      ///
      /// Locales: en, ko
      static let needSaveTitle = Rswift.StringResource(key: "needSaveTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: camera
      ///
      /// Locales: en, ko
      static let camera = Rswift.StringResource(key: "camera", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: cancel
      ///
      /// Locales: en, ko
      static let cancel = Rswift.StringResource(key: "cancel", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: cancle
      ///
      /// Locales: en, ko
      static let cancle = Rswift.StringResource(key: "cancle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: complete!
      ///
      /// Locales: en, ko
      static let moveComplete = Rswift.StringResource(key: "moveComplete", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: content
      ///
      /// Locales: en, ko
      static let content = Rswift.StringResource(key: "content", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: diary
      ///
      /// Locales: en, ko
      static let diary = Rswift.StringResource(key: "diary", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: error!
      ///
      /// Locales: en, ko
      static let error = Rswift.StringResource(key: "error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: error!Please select the image again
      ///
      /// Locales: en, ko
      static let imageLoadingError = Rswift.StringResource(key: "imageLoadingError", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: folder
      ///
      /// Locales: en, ko
      static let folder = Rswift.StringResource(key: "folder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: folder name
      ///
      /// Locales: en, ko
      static let folderName = Rswift.StringResource(key: "folderName", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: image
      ///
      /// Locales: en, ko
      static let image = Rswift.StringResource(key: "image", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: latest version
      ///
      /// Locales: en, ko
      static let notNeedUpdate = Rswift.StringResource(key: "notNeedUpdate", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: need update
      ///
      /// Locales: en, ko
      static let needUpdate = Rswift.StringResource(key: "needUpdate", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: next
      ///
      /// Locales: en, ko
      static let next = Rswift.StringResource(key: "next", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: not classified
      ///
      /// Locales: en, ko
      static let notClassified = Rswift.StringResource(key: "notClassified", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: ok
      ///
      /// Locales: en, ko
      static let ok = Rswift.StringResource(key: "ok", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: opensource license
      ///
      /// Locales: en, ko
      static let openSourceLicense = Rswift.StringResource(key: "openSourceLicense", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: privacy policy
      ///
      /// Locales: en, ko
      static let privacy = Rswift.StringResource(key: "privacy", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: save
      ///
      /// Locales: en, ko
      static let save = Rswift.StringResource(key: "save", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: saved
      ///
      /// Locales: en, ko
      static let editSave = Rswift.StringResource(key: "editSave", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: saved
      ///
      /// Locales: en, ko
      static let imageSaveComplete = Rswift.StringResource(key: "imageSaveComplete", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: saving
      ///
      /// Locales: en, ko
      static let imageSaving = Rswift.StringResource(key: "imageSaving", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: select
      ///
      /// Locales: en, ko
      static let select = Rswift.StringResource(key: "select", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: select a folder to move
      ///
      /// Locales: en, ko
      static let selectFolder = Rswift.StringResource(key: "selectFolder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: select tag
      ///
      /// Locales: en, ko
      static let selectTag = Rswift.StringResource(key: "selectTag", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)

      /// en translation: Add Folder
      ///
      /// Locales: en, ko
      static func addFolderTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("addFolderTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "addFolderTitle"
        }

        return NSLocalizedString("addFolderTitle", bundle: bundle, comment: "")
      }

      /// en translation: Do you really want to delete the diary?
      ///
      /// Locales: en, ko
      static func deleteDiaryMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("deleteDiaryMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "deleteDiaryMessage"
        }

        return NSLocalizedString("deleteDiaryMessage", bundle: bundle, comment: "")
      }

      /// en translation: Do you really want to delete the folder? All images in the folder will be deleted.
      ///
      /// Locales: en, ko
      static func deleteFolderMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("deleteFolderMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "deleteFolderMessage"
        }

        return NSLocalizedString("deleteFolderMessage", bundle: bundle, comment: "")
      }

      /// en translation: Folder creation has been canceled
      ///
      /// Locales: en, ko
      static func addFolderCancleToast(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("addFolderCancleToast", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "addFolderCancleToast"
        }

        return NSLocalizedString("addFolderCancleToast", bundle: bundle, comment: "")
      }

      /// en translation: Folder creation has been failed
      ///
      /// Locales: en, ko
      static func addFolderFailToast(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("addFolderFailToast", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "addFolderFailToast"
        }

        return NSLocalizedString("addFolderFailToast", bundle: bundle, comment: "")
      }

      /// en translation: If you leave this page, the created content will not be saved. Please save the contents.
      ///
      /// Locales: en, ko
      static func needSaveMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("needSaveMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "needSaveMessage"
        }

        return NSLocalizedString("needSaveMessage", bundle: bundle, comment: "")
      }

      /// en translation: My Diary
      ///
      /// Locales: en, ko
      static func myDiary(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("my diary", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "my diary"
        }

        return NSLocalizedString("my diary", bundle: bundle, comment: "")
      }

      /// en translation: Please enter a text that's not blank
      ///
      /// Locales: en, ko
      static func addFolderEmptyName(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("addFolderEmptyName", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "addFolderEmptyName"
        }

        return NSLocalizedString("addFolderEmptyName", bundle: bundle, comment: "")
      }

      /// en translation: Please enter it in 15 letters or less
      ///
      /// Locales: en, ko
      static func addFolderLongName(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("addFolderLongName", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "addFolderLongName"
        }

        return NSLocalizedString("addFolderLongName", bundle: bundle, comment: "")
      }

      /// en translation: Please enter less than 1,000 characters.
      ///
      /// Locales: en, ko
      static func longContent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("longContent", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "longContent"
        }

        return NSLocalizedString("longContent", bundle: bundle, comment: "")
      }

      /// en translation: Please enter the folder name you want to add
      ///
      /// Locales: en, ko
      static func addFolderMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("addFolderMessage", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "addFolderMessage"
        }

        return NSLocalizedString("addFolderMessage", bundle: bundle, comment: "")
      }

      /// en translation: Please make a timestamp image!
      ///
      /// Locales: en, ko
      static func guide(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("guide", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "guide"
        }

        return NSLocalizedString("guide", bundle: bundle, comment: "")
      }

      /// en translation: Setting
      ///
      /// Locales: en, ko
      static func setting(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("setting", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "setting"
        }

        return NSLocalizedString("setting", bundle: bundle, comment: "")
      }

      /// en translation: There's no diary yet!
      ///
      /// Locales: en, ko
      static func noDiary(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("noDiary", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "noDiary"
        }

        return NSLocalizedString("noDiary", bundle: bundle, comment: "")
      }

      /// en translation: add
      ///
      /// Locales: en, ko
      static func add(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("add", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "add"
        }

        return NSLocalizedString("add", bundle: bundle, comment: "")
      }

      /// en translation: album
      ///
      /// Locales: en, ko
      static func album(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("album", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "album"
        }

        return NSLocalizedString("album", bundle: bundle, comment: "")
      }

      /// en translation: alert
      ///
      /// Locales: en, ko
      static func alert(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("alert", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "alert"
        }

        return NSLocalizedString("alert", bundle: bundle, comment: "")
      }

      /// en translation: all
      ///
      /// Locales: en, ko
      static func all(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("all", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "all"
        }

        return NSLocalizedString("all", bundle: bundle, comment: "")
      }

      /// en translation: app is not allowed to access the camera. Do you want to go to the setting screen?
      ///
      /// Locales: en, ko
      static func accessSetting(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("accessSetting", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "accessSetting"
        }

        return NSLocalizedString("accessSetting", bundle: bundle, comment: "")
      }

      /// en translation: app version
      ///
      /// Locales: en, ko
      static func appVersion(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("appVersion", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "appVersion"
        }

        return NSLocalizedString("appVersion", bundle: bundle, comment: "")
      }

      /// en translation: attention
      ///
      /// Locales: en, ko
      static func needSaveTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("needSaveTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "needSaveTitle"
        }

        return NSLocalizedString("needSaveTitle", bundle: bundle, comment: "")
      }

      /// en translation: camera
      ///
      /// Locales: en, ko
      static func camera(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("camera", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "camera"
        }

        return NSLocalizedString("camera", bundle: bundle, comment: "")
      }

      /// en translation: cancel
      ///
      /// Locales: en, ko
      static func cancel(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("cancel", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "cancel"
        }

        return NSLocalizedString("cancel", bundle: bundle, comment: "")
      }

      /// en translation: cancle
      ///
      /// Locales: en, ko
      static func cancle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("cancle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "cancle"
        }

        return NSLocalizedString("cancle", bundle: bundle, comment: "")
      }

      /// en translation: complete!
      ///
      /// Locales: en, ko
      static func moveComplete(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("moveComplete", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "moveComplete"
        }

        return NSLocalizedString("moveComplete", bundle: bundle, comment: "")
      }

      /// en translation: content
      ///
      /// Locales: en, ko
      static func content(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("content", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "content"
        }

        return NSLocalizedString("content", bundle: bundle, comment: "")
      }

      /// en translation: diary
      ///
      /// Locales: en, ko
      static func diary(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("diary", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "diary"
        }

        return NSLocalizedString("diary", bundle: bundle, comment: "")
      }

      /// en translation: error!
      ///
      /// Locales: en, ko
      static func error(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "error"
        }

        return NSLocalizedString("error", bundle: bundle, comment: "")
      }

      /// en translation: error!Please select the image again
      ///
      /// Locales: en, ko
      static func imageLoadingError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("imageLoadingError", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "imageLoadingError"
        }

        return NSLocalizedString("imageLoadingError", bundle: bundle, comment: "")
      }

      /// en translation: folder
      ///
      /// Locales: en, ko
      static func folder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("folder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "folder"
        }

        return NSLocalizedString("folder", bundle: bundle, comment: "")
      }

      /// en translation: folder name
      ///
      /// Locales: en, ko
      static func folderName(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("folderName", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "folderName"
        }

        return NSLocalizedString("folderName", bundle: bundle, comment: "")
      }

      /// en translation: image
      ///
      /// Locales: en, ko
      static func image(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("image", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "image"
        }

        return NSLocalizedString("image", bundle: bundle, comment: "")
      }

      /// en translation: latest version
      ///
      /// Locales: en, ko
      static func notNeedUpdate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("notNeedUpdate", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "notNeedUpdate"
        }

        return NSLocalizedString("notNeedUpdate", bundle: bundle, comment: "")
      }

      /// en translation: need update
      ///
      /// Locales: en, ko
      static func needUpdate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("needUpdate", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "needUpdate"
        }

        return NSLocalizedString("needUpdate", bundle: bundle, comment: "")
      }

      /// en translation: next
      ///
      /// Locales: en, ko
      static func next(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("next", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "next"
        }

        return NSLocalizedString("next", bundle: bundle, comment: "")
      }

      /// en translation: not classified
      ///
      /// Locales: en, ko
      static func notClassified(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("notClassified", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "notClassified"
        }

        return NSLocalizedString("notClassified", bundle: bundle, comment: "")
      }

      /// en translation: ok
      ///
      /// Locales: en, ko
      static func ok(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ok", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ok"
        }

        return NSLocalizedString("ok", bundle: bundle, comment: "")
      }

      /// en translation: opensource license
      ///
      /// Locales: en, ko
      static func openSourceLicense(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("openSourceLicense", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "openSourceLicense"
        }

        return NSLocalizedString("openSourceLicense", bundle: bundle, comment: "")
      }

      /// en translation: privacy policy
      ///
      /// Locales: en, ko
      static func privacy(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("privacy", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "privacy"
        }

        return NSLocalizedString("privacy", bundle: bundle, comment: "")
      }

      /// en translation: save
      ///
      /// Locales: en, ko
      static func save(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("save", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "save"
        }

        return NSLocalizedString("save", bundle: bundle, comment: "")
      }

      /// en translation: saved
      ///
      /// Locales: en, ko
      static func editSave(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("editSave", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "editSave"
        }

        return NSLocalizedString("editSave", bundle: bundle, comment: "")
      }

      /// en translation: saved
      ///
      /// Locales: en, ko
      static func imageSaveComplete(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("imageSaveComplete", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "imageSaveComplete"
        }

        return NSLocalizedString("imageSaveComplete", bundle: bundle, comment: "")
      }

      /// en translation: saving
      ///
      /// Locales: en, ko
      static func imageSaving(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("imageSaving", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "imageSaving"
        }

        return NSLocalizedString("imageSaving", bundle: bundle, comment: "")
      }

      /// en translation: select
      ///
      /// Locales: en, ko
      static func select(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("select", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "select"
        }

        return NSLocalizedString("select", bundle: bundle, comment: "")
      }

      /// en translation: select a folder to move
      ///
      /// Locales: en, ko
      static func selectFolder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("selectFolder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "selectFolder"
        }

        return NSLocalizedString("selectFolder", bundle: bundle, comment: "")
      }

      /// en translation: select tag
      ///
      /// Locales: en, ko
      static func selectTag(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("selectTag", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "selectTag"
        }

        return NSLocalizedString("selectTag", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _TagAlbumCollectionViewCell.validate()
    }

    struct _DesignCollectionViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = DesignCollectionViewCell

      let bundle = R.hostingBundle
      let identifier = "DesignCollectionViewCell"
      let name = "DesignCollectionViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> DesignCollectionViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? DesignCollectionViewCell
      }

      fileprivate init() {}
    }

    struct _Stamp_10: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_10"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_11: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_11"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_12: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_12"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_13: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_13"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_14: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_14"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_15: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_15"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_1: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_1"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_2: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_2"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_3: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_3"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_4: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_4"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_5: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_5"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_6: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_6"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_7: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_7"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_8: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_8"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _Stamp_9: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "Stamp_9"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _TagAlbumCollectionViewCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType, Rswift.Validatable {
      typealias ReusableType = TagAlbumCollectionViewCell

      let bundle = R.hostingBundle
      let identifier = "TagAlbumCollectionViewCell"
      let name = "TagAlbumCollectionViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TagAlbumCollectionViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TagAlbumCollectionViewCell
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "circle") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'circle' is used in nib 'TagAlbumCollectionViewCell', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try addDiary.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try imageEdit.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try openSourceLicense.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try privacy.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userAlbum.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userAppVersion.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userDiary.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userSetting.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userTagAlbum.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userTagAlbumDetail.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try userTagSelect.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct addDiary: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = AddDiaryViewController

      let addDiaryViewController = StoryboardViewControllerResource<AddDiaryViewController>(identifier: "AddDiaryViewController")
      let bundle = R.hostingBundle
      let name = "AddDiary"

      func addDiaryViewController(_: Void = ()) -> AddDiaryViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: addDiaryViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bear", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bear' is used in storyboard 'AddDiary', but couldn't be loaded.") }
        }
        if _R.storyboard.addDiary().addDiaryViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'addDiaryViewController' could not be loaded from storyboard 'AddDiary' as 'AddDiaryViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct imageEdit: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UINavigationController

      let bundle = R.hostingBundle
      let imageEditViewController = StoryboardViewControllerResource<ImageEditViewController>(identifier: "ImageEditViewController")
      let name = "ImageEdit"

      func imageEditViewController(_: Void = ()) -> ImageEditViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: imageEditViewController)
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.backward") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.backward' is used in storyboard 'ImageEdit', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "chevron.right") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'chevron.right' is used in storyboard 'ImageEdit', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "minus") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'minus' is used in storyboard 'ImageEdit', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "paintbrush.pointed.fill") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'paintbrush.pointed.fill' is used in storyboard 'ImageEdit', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "plus") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'plus' is used in storyboard 'ImageEdit', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bear", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bear' is used in storyboard 'ImageEdit', but couldn't be loaded.") }
        }
        if _R.storyboard.imageEdit().imageEditViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'imageEditViewController' could not be loaded from storyboard 'ImageEdit' as 'ImageEditViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "TimeBearTitle1", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'TimeBearTitle1' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct openSourceLicense: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "OpenSourceLicense"
      let openSourceLicenseViewController = StoryboardViewControllerResource<OpenSourceLicenseViewController>(identifier: "OpenSourceLicenseViewController")

      func openSourceLicenseViewController(_: Void = ()) -> OpenSourceLicenseViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: openSourceLicenseViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.openSourceLicense().openSourceLicenseViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'openSourceLicenseViewController' could not be loaded from storyboard 'OpenSourceLicense' as 'OpenSourceLicenseViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct privacy: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "Privacy"
      let privacyViewController = StoryboardViewControllerResource<PrivacyViewController>(identifier: "PrivacyViewController")

      func privacyViewController(_: Void = ()) -> PrivacyViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: privacyViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.privacy().privacyViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'privacyViewController' could not be loaded from storyboard 'Privacy' as 'PrivacyViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userAlbum: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UITabBarController

      let bundle = R.hostingBundle
      let name = "UserAlbum"
      let userAlbumViewController = StoryboardViewControllerResource<UserAlbumViewController>(identifier: "UserAlbumViewController")

      func userAlbumViewController(_: Void = ()) -> UserAlbumViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userAlbumViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "TimeBearTitle1", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'TimeBearTitle1' is used in storyboard 'UserAlbum', but couldn't be loaded.") }
        if UIKit.UIImage(named: "TimeBear_Clear_25", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'TimeBear_Clear_25' is used in storyboard 'UserAlbum', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "camera") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'camera' is used in storyboard 'UserAlbum', but couldn't be loaded.") } }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "photo.on.rectangle") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'photo.on.rectangle' is used in storyboard 'UserAlbum', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bear", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bear' is used in storyboard 'UserAlbum', but couldn't be loaded.") }
        }
        if _R.storyboard.userAlbum().userAlbumViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userAlbumViewController' could not be loaded from storyboard 'UserAlbum' as 'UserAlbumViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userAppVersion: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "UserAppVersion"
      let userAppVersionViewController = StoryboardViewControllerResource<UserAppVersionViewController>(identifier: "UserAppVersionViewController")

      func userAppVersionViewController(_: Void = ()) -> UserAppVersionViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userAppVersionViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "TimeBear_Clear_500", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'TimeBear_Clear_500' is used in storyboard 'UserAppVersion', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bear", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bear' is used in storyboard 'UserAppVersion', but couldn't be loaded.") }
        }
        if _R.storyboard.userAppVersion().userAppVersionViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userAppVersionViewController' could not be loaded from storyboard 'UserAppVersion' as 'UserAppVersionViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userDiary: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UserDiaryViewController

      let bundle = R.hostingBundle
      let name = "UserDiary"
      let userDiary = StoryboardViewControllerResource<UserDiaryViewController>(identifier: "UserDiary")

      func userDiary(_: Void = ()) -> UserDiaryViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userDiary)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "TimeBear_Clear_100", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'TimeBear_Clear_100' is used in storyboard 'UserDiary', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.userDiary().userDiary() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userDiary' could not be loaded from storyboard 'UserDiary' as 'UserDiaryViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userSetting: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UserSettingViewController

      let bundle = R.hostingBundle
      let name = "UserSetting"
      let userSetting = StoryboardViewControllerResource<UserSettingViewController>(identifier: "UserSetting")

      func userSetting(_: Void = ()) -> UserSettingViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userSetting)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.userSetting().userSetting() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userSetting' could not be loaded from storyboard 'UserSetting' as 'UserSettingViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userTagAlbum: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "UserTagAlbum"
      let userTagAlbumViewController = StoryboardViewControllerResource<UserTagAlbumViewController>(identifier: "UserTagAlbumViewController")

      func userTagAlbumViewController(_: Void = ()) -> UserTagAlbumViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userTagAlbumViewController)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.userTagAlbum().userTagAlbumViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userTagAlbumViewController' could not be loaded from storyboard 'UserTagAlbum' as 'UserTagAlbumViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userTagAlbumDetail: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "UserTagAlbumDetail"
      let userTagAlbumDetailViewController = StoryboardViewControllerResource<UserTagAlbumDetailViewController>(identifier: "UserTagAlbumDetailViewController")

      func userTagAlbumDetailViewController(_: Void = ()) -> UserTagAlbumDetailViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userTagAlbumDetailViewController)
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "square.and.arrow.up") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'square.and.arrow.up' is used in storyboard 'UserTagAlbumDetail', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "bear", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'bear' is used in storyboard 'UserTagAlbumDetail', but couldn't be loaded.") }
        }
        if _R.storyboard.userTagAlbumDetail().userTagAlbumDetailViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userTagAlbumDetailViewController' could not be loaded from storyboard 'UserTagAlbumDetail' as 'UserTagAlbumDetailViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct userTagSelect: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "UserTagSelect"
      let userTagSelectViewController = StoryboardViewControllerResource<UserTagSelectViewController>(identifier: "UserTagSelectViewController")

      func userTagSelectViewController(_: Void = ()) -> UserTagSelectViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userTagSelectViewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "TimeBear_Clear_100", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'TimeBear_Clear_100' is used in storyboard 'UserTagSelect', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.userTagSelect().userTagSelectViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userTagSelectViewController' could not be loaded from storyboard 'UserTagSelect' as 'UserTagSelectViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
